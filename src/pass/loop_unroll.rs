/// Phase 90a: Loop unrolling pass.
///
/// Unrolls `for i in start..end` loops where:
/// - Both start and end are `ConstInt` values with known trip count ≤ `max_unroll`.
/// - The loop body is a single block (no internal branches).
///
/// The IR pattern generated by the lowerer:
///   entry: start_const, end_const → Br header(%start_const)
///   header(%i): CmpLt %i, %end → CondBr → body | exit
///   body: ... uses %i ... end_const(1) → Add %i, 1 → Br header(%next_i)
///   exit: ...
///
/// After unrolling, the header and body blocks are replaced with N inline copies.
use std::collections::HashMap;

use crate::ir::block::{BlockId, IrBlock};
use crate::ir::instr::{BinOp, IrInstr};
use crate::ir::module::IrModule;
use crate::ir::types::IrType;
use crate::ir::value::ValueId;
use crate::pass::PassError;

pub struct LoopUnrollPass {
    pub max_unroll: usize,
}

impl Default for LoopUnrollPass {
    fn default() -> Self { Self { max_unroll: 8 } }
}

impl super::Pass for LoopUnrollPass {
    fn name(&self) -> &'static str { "loop-unroll" }

    fn run(&mut self, module: &mut IrModule) -> Result<(), PassError> {
        let threshold = self.max_unroll;
        let num_fns = module.functions.len();
        for fn_idx in 0..num_fns {
            unroll_loops_in_function(module, fn_idx, threshold);
        }
        Ok(())
    }
}

/// Try to unroll loops in one function.
fn unroll_loops_in_function(module: &mut IrModule, fn_idx: usize, threshold: usize) {
    let num_blocks = module.functions[fn_idx].blocks.len();

    // 1. Find blocks that are loop headers:
    //    A block is a loop header if it has exactly one block param (the loop variable)
    //    and its terminator is a CondBr.
    for header_idx in 0..num_blocks {
        // Check: header has one block param
        if module.functions[fn_idx].blocks[header_idx].params.len() != 1 {
            continue;
        }
        // Check: header terminator is CondBr
        let header_term = module.functions[fn_idx].blocks[header_idx]
            .instrs.last().cloned();
        let (cond_val, then_block, else_block) = match header_term {
            Some(IrInstr::CondBr { cond, then_block, else_block, .. }) => (cond, then_block, else_block),
            _ => continue,
        };

        // Check: the condition is a CmpLt BinOp where rhs is a ConstInt
        let (cmp_lhs, end_const) = {
            let mut found = None;
            for instr in &module.functions[fn_idx].blocks[header_idx].instrs {
                if let IrInstr::BinOp { result, op: BinOp::CmpLt, lhs, rhs, .. } = instr {
                    if *result == cond_val {
                        found = Some((*lhs, *rhs));
                        break;
                    }
                }
            }
            match found { Some(x) => x, None => continue }
        };

        // Look up end_const value
        let end_val = find_const_int(module, fn_idx, end_const);
        let end_val = match end_val { Some(v) => v, None => continue };

        // The header's block param IS cmp_lhs (the loop variable i)
        let header_param_id = module.functions[fn_idx].blocks[header_idx].params[0].id;
        if cmp_lhs != header_param_id { continue; }

        // Find start value: look for a Br to the header in the predecessor
        // (we'll look for any block that does Br to this header with a single arg that is a ConstInt)
        let header_bid = BlockId(header_idx as u32);
        let start_val = {
            let mut found = None;
            for bi in 0..num_blocks {
                if bi == header_idx { continue; }
                let term = module.functions[fn_idx].blocks[bi].instrs.last();
                if let Some(IrInstr::Br { target, args }) = term {
                    if *target == header_bid && args.len() == 1 {
                        if let Some(v) = find_const_int(module, fn_idx, args[0]) {
                            found = Some(v);
                            break;
                        }
                    }
                }
            }
            match found { Some(v) => v, None => continue }
        };

        let trip_count = (end_val - start_val).max(0) as usize;
        if trip_count == 0 || trip_count > threshold { continue; }

        // body_block is then_block
        let body_idx = then_block.0 as usize;
        let exit_bid = else_block;

        // Check: body is single block with Br back to header (no internal CondBr)
        {
            let body_instrs = &module.functions[fn_idx].blocks[body_idx].instrs;
            let has_cond_br = body_instrs.iter().any(|i| matches!(i, IrInstr::CondBr { .. }));
            if has_cond_br { continue; }
            match body_instrs.last() {
                Some(IrInstr::Br { target, .. }) if *target == header_bid => {}
                _ => continue,
            }
        }

        // 2. Unroll: create trip_count inline copies of the body.
        // Build a fresh block that contains all inlined iterations.
        let unrolled_bid = BlockId(module.functions[fn_idx].blocks.len() as u32);
        module.functions[fn_idx].blocks.push(IrBlock::new(unrolled_bid, Some("unrolled".to_owned())));

        let mut current_i_val: Option<ValueId> = None; // tracks the current i value (for adding back)

        for iter in 0..trip_count {
            let i_const_val = start_val + iter as i64;

            // Allocate a fresh ConstInt for this iteration's i value.
            let i_const = module.functions[fn_idx].fresh_value();
            let body_ty = module.functions[fn_idx].blocks[header_idx].params[0].ty.clone();
            module.functions[fn_idx].blocks[unrolled_bid.0 as usize].instrs.push(
                IrInstr::ConstInt { result: i_const, value: i_const_val, ty: body_ty.clone() }
            );

            // Build val_map: header_param_id → i_const, plus remap body results.
            let mut val_map: HashMap<ValueId, ValueId> = HashMap::new();
            val_map.insert(header_param_id, i_const);
            if let Some(prev) = current_i_val {
                // Previous iteration's next-i might be referenced; also map it.
                val_map.insert(prev, i_const);
            }

            // Clone non-terminator body instructions.
            let body_instrs: Vec<IrInstr> = module.functions[fn_idx].blocks[body_idx]
                .instrs.iter()
                .filter(|i| !i.is_terminator())
                .cloned()
                .collect();

            for mut bi in body_instrs {
                if let Some(old_result) = bi.result() {
                    let fresh = module.functions[fn_idx].fresh_value();
                    val_map.insert(old_result, fresh);
                    crate::pass::inline::set_result(&mut bi, fresh);
                }
                crate::pass::opt::apply_replacements(&mut bi, &val_map);
                module.functions[fn_idx].blocks[unrolled_bid.0 as usize].instrs.push(bi);
            }

            // The "next i" produced by this iteration is val_map[Add result in body].
            // Find it by looking for the Add instruction in the body.
            for old_instr in &module.functions[fn_idx].blocks[body_idx].instrs {
                if let IrInstr::BinOp { result, op: BinOp::Add, lhs, .. } = old_instr {
                    if *lhs == header_param_id {
                        current_i_val = val_map.get(result).copied();
                        break;
                    }
                }
            }
        }

        // Terminate unrolled block by jumping to exit.
        module.functions[fn_idx].blocks[unrolled_bid.0 as usize].instrs.push(
            IrInstr::Br { target: exit_bid, args: vec![] }
        );

        // Patch the predecessor block(s) that had Br to header → now Br to unrolled.
        for bi in 0..num_blocks {
            let term = module.functions[fn_idx].blocks[bi].instrs.last_mut();
            if let Some(IrInstr::Br { target, args }) = term {
                if *target == header_bid && !args.is_empty() {
                    // This is the entry br to the header — redirect to unrolled.
                    *target = unrolled_bid;
                    args.clear();
                }
            }
        }

        // The exit block might have block params that receive the loop variable.
        // Check if CondBr had else_args; remove them since we don't pass i anymore.
        // (Already covered since unrolled block uses Br with no args.)

        // Mark header and body as dead by replacing with Br to exit.
        // (DCE will clean them up, but we need to keep them valid.)
        // Replace header instrs with just a Br to exit.
        module.functions[fn_idx].blocks[header_idx].params.clear();
        module.functions[fn_idx].blocks[header_idx].instrs.clear();
        module.functions[fn_idx].blocks[header_idx].instrs.push(
            IrInstr::Br { target: exit_bid, args: vec![] }
        );

        // Only process one loop per function pass to avoid block index invalidation.
        break;
    }
}

/// Find the i64 constant value of a ValueId, if it's defined by ConstInt.
fn find_const_int(module: &IrModule, fn_idx: usize, vid: ValueId) -> Option<i64> {
    for block in &module.functions[fn_idx].blocks {
        for instr in &block.instrs {
            if let IrInstr::ConstInt { result, value, .. } = instr {
                if *result == vid {
                    return Some(*value);
                }
            }
        }
    }
    // Also check block params — not a constant.
    None
}
