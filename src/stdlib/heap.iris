// src/stdlib/heap.iris -- IRIS standard min-heap (i64, sorted-list implementation)

record MinHeap { data: list<i64> }

pub def heap_new() -> MinHeap {
    MinHeap { data: list() }
}

pub def heap_len(h: MinHeap) -> i64 {
    list_len(h.data)
}

// Returns the minimum element (front of sorted list).
pub def heap_peek(h: MinHeap) -> i64 {
    list_get(h.data, 0)
}

// Returns the minimum element.
pub def heap_pop_val(h: MinHeap) -> i64 {
    list_get(h.data, 0)
}

// Returns a new heap with the minimum element removed.
pub def heap_pop_heap(h: MinHeap) -> MinHeap {
    var new_data = list()
    var i = 1
    val n = list_len(h.data)
    while i < n {
        push(new_data, list_get(h.data, i));
        i = i + 1
    }
    MinHeap { data: new_data }
}

// Inserts v into the heap maintaining sorted (ascending) order.
pub def heap_push(h: MinHeap, v: i64) -> MinHeap {
    var new_data = list()
    var inserted = 0
    var i = 0
    val n = list_len(h.data)
    while i < n {
        val cur = list_get(h.data, i)
        val should_insert = if cur > v { if inserted == 0 { 1 } else { 0 } } else { 0 }
        inserted = if should_insert == 1 { 1 } else { inserted }
        val _ = if should_insert == 1 { push(new_data, v); 0 } else { 0 }
        push(new_data, cur);
        i = i + 1
    }
    val _ = if inserted == 0 { push(new_data, v); 0 } else { 0 }
    MinHeap { data: new_data }
}
